# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' LLM 
#'
#' Computes mean field variational bayes estimates of a LLM with structured spike and slab priors with p fixed and n random effect coefficients.
#'
#' @param y vector. Dependent measurements.
#' @param X Matrix. Fixed effects model matrix
#' @param A Matrix. Covariance structure of random effects = tau * A
#' @param lambda_0. Variance of spike distribution
#' @param lambda_1. Variance of slab distribution
#' @param v vector. Eigenvectors of tridiagonal pxp matrix with 0s on diagonal and 1 on the off-diagonal
#' @param inits List. Order is eta, mu_beta, Sigma_beta, mu_delta, Sigma_delta sig_inv, tau, mu_gamma, mu_theta, t
#' @param epsilon = 1e-4. ELBO convergence
#' @param max_iter = 200. Maximum number of iterations
#' @param a_sigma = 1. Hyper parameter of sigma (shape)
#' @param b_sigma = 1. Hyper parameter of sigma (scale)
#' @param a_tau = 1. Hyper parameter of tau (shape)
#' @param b_tau = 1. Hyper parameter of tau (scale)
#'
#' @return List of results
#'
#' @export
vi_gauss <- function(y, X, A, lambda_0, lambda_1, v, inits, epsilon = 1e-4, max_iter = 200L, a_sigma = 1.0, b_sigma = 1.0, a_tau = 1.0, b_tau = 1.0) {
    .Call(`_StSS_vi_gauss`, y, X, A, lambda_0, lambda_1, v, inits, epsilon, max_iter, a_sigma, b_sigma, a_tau, b_tau)
}

#' Poisson gllm
#'
#' Computes mean field variational bayes estimates of poisson GLLM with structured spike and slab priors with p fixed and k random effect coefficients.
#'
#' @param y vector. Dependent measurements.
#' @param C Matrix. Concatenated fixed and random effects model matrices in said order
#' @param log_s vector. Log offset.
#' @param lambda_0. Variance of spike distribution
#' @param lambda_1. Variance of slab distribution
#' @param v vector. Eigenvectors of tridiagonal pxp matrix with 0s on diagonal and 1 on the off-diagonal
#' @param inits List. Order is eta, mu_(beta, delta), Sigma_(beta, delta), sig_inv, mu_gamma, mu_theta, t
#' @param epsilon = 1e-4. ELBO convergence
#' @param max_iter = 200. Maximum number of iterations
#' @param a = 1. Hyper parameter of sigma (shape)
#' @param b = 1. Hyper parameter of sigma (scale)
#'
#' @return List of results
#'
#' @export
vi_poisson <- function(y, C, log_s, lambda_0, lambda_1, v, inits, epsilon = 1e-4, max_iter = 200L, a = 1.0, b = 1.0) {
    .Call(`_StSS_vi_poisson`, y, C, log_s, lambda_0, lambda_1, v, inits, epsilon, max_iter, a, b)
}

#' From the Jaakkola lower bound
NULL

#' Avoiding overflow
NULL

#' Compute logistic with lower bound
logistic <- function(x, lower) {
    .Call(`_StSS_logistic`, x, lower)
}

#' Compute logit with lower bound
logit <- function(x, lower) {
    .Call(`_StSS_logit`, x, lower)
}

#' Computes tridiagonal matrix, rho = offdiag
tri_diagonal <- function(n, rho, diagVal) {
    .Call(`_StSS_tri_diagonal`, n, rho, diagVal)
}

#' Computes the diagonal matrix of indiciators for beta
beta_mat <- function(muInd, lambda_0, lambda_1) {
    .Call(`_StSS_beta_mat`, muInd, lambda_0, lambda_1)
}

#' Compute a adjencey graph
compute_weight_matrix <- function(coords, cutoff) {
    .Call(`_StSS_compute_weight_matrix`, coords, cutoff)
}

hess_q_eta <- function(eta, mu, Sigma, v) {
    .Call(`_StSS_hess_q_eta`, eta, mu, Sigma, v)
}

E_elbo_eta <- function(eta, eta_var, v, nMC) {
    .Call(`_StSS_E_elbo_eta`, eta, eta_var, v, nMC)
}

